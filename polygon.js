'use strict';

const PI2 = Math.PI * 2; // 360도를 라디안으로 표현한 값이지? 원 그릴 때 쓰겠네 

// 꼭지점의 사각형들마다 다른 컬러로 지정해주려고 만든거 
const COLORS = [
  '#4b45ab',
  '#554fb8',
  '#605ac7',
  '#2a91a8',
  '#2e9ab2',
  '#32a5bf',
  '#81b114',
  '#85b944',
  '#8fc549',
  '#e0af27',
  '#eeba2a',
  '#fec72e',
  '#bf342d',
  '#ca3931',
  '#d7423a',
];

export class Polygon {
  constructor(x, y, radius, sides) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.sides = sides;
    this.rotate = 0;
  }
  // 참고로 여기서 radius는 Polgon의 중심점에서 Polygon의 각 꼭지점까지의 거리로 활용함.
  // radius라고 해서 꼭 원의 반지름만 의미하는 게 아님.

  // sides(변의 개수)에 따라 Polygon을 그리는 메소드
  animate(ctx, moveX) {
    ctx.save(); // canvas의 현재 속성 및 상태를 저장하는 것. 주로 restore()랑 같이 transform 시 사용한다고 했지?
    // ctx.fillStyle = '#000'; 가운데에 회전 도형 하나만 그릴 때 기본 컬러 지정했던 거
    // ctx.beginPath(); 가운데에 회전 도형 하나만 그릴 경우

    const angle = PI2 / this.sides;
    // sides에 할당된 개수에 따라 360도의 라디안값이 나눠진 라디안 각도가 할당됨.
    // 360도가 sides 개수에 따라 n개로 나눠져서 angle은 side 1개에 해당하는 라디안 각도를 할당받는 거 같음.
    // 삼각형이면 3개니까 120도, 사각형이면 4개니까 90도의 라디안값이 할당될거임.

    const angle2 = PI2 / 4; // 꼭지점마다 사각형 생성하려고 할당해준 각도. 사각형이니까 90도의 라디안 값이겠지?

    ctx.translate(this.x, this.y);
    // canvas의 원점을 (0, 0)에서 (this.x, this.y)로 옮김. 이제부터는 여기가 원점(0, 0)이 됨.
    // 도형의 위치 설정도 이 원점을 기준으로 설정됨.

    // 1. 왜 -= 로 moveX값을 감소연산 시켜서 this.rotate각도를 구할까?
    // 방향의 문제! 마우스 클릭 후 오른쪽으로 드래그(moveX가 +가 됨.)하면 반시계방향(각도를 -로 전달해야 함.)으로 돌리고 싶고
    // 왼쪽으로 드래그(moveX가 -가 됨)하면 시계방향(각도를 +로 전달해야 함)으로 돌리고 싶어서 -=로 부호를 바꿔서 더해준 것.
    // 2. 또 하나! 왜 * 0.008을 하나? 
    // app.js에서 프레임마다 moveX * 0.92 하게 했으니 그냥 -= moveX 이렇게 하더라도 감속해서 언젠가 멈추긴 하겠지만,
    // moveX를 쌩으로 넣어버리면 너무 빨리 감속해버림. 즉, 너무 빨리 돌았다가 너무 빨리 멈춰버림.
    // 천천히 돌았다가 천천히 멈추게 하기 위해서, 즉 각도의 변화를 조금씩만 주기 위해 매번 감소된 moveX 마다 0.008을 곱해준 거임.
    this.rotate -= moveX * 0.008;
    ctx.rotate(this.rotate);
    // rotate(angle)
    // 캔버스를 현재 원점을 기준으로 라디안의 angle(라디안값으로 전달해야 함.) 숫자만큼 시계방향으로 회전시킴.
    // 회전의 중심점은 언제나 캔버스의 원점.

    // 이 for loop는 뭐냐면, sides의 개수(Polygon에서 변의 개수 = 꼭지점의 개수)에 따라
    // 각 꼭지점의 x, y좌표값을 생성하고 그 좌표값으로 path를 그리는 반복문임.
    for (let i = 0; i < this.sides; i++) {
      /**
       * Math.sin vs Math.cos
       * 
       * cos도 sin처럼 라디안값에 따라 -1 ~ 1 사이의 값을 return해줌.
       * 그러면 무슨 차이가 있냐?
       * 
       * 사인 그래프와 코사인 그래프를 검색해서 비교해보면, 둘이 모양도 똑같고 패턴도 똑같지만
       * cos가 sin 그래프에 비해 x축 상에서 더 왼쪽에 위치해 있음. 
       * 얼만큼 왼쪽에 있는거냐면, x축의 라디안값들을 degree 단위로 변환했다고 가정하고 90도만큼 X축에서 왼쪽으로 치우쳐짐.
       * 
       * 이로 인해 어떤 차이가 생기냐면
       * 위에 처럼 angle * i 로 같은 radian값을 넣었을 때 sin과 cos각각 return받는 값이 항상 1 만큼 차이가 남.
       * sin이 1을 리턴하면 cos는 0을 리턴하고, sin이 -1이면 cos는 0을 리턴하고, sin이 0.5를 리턴하면 cos는 -0.5 리턴함.
       * 따라서 const x, y는 항상 서로 1씩 차이나는 값을 각각 할당받게 됨.
       * 
       * 사실 이건 중요한 게 아니고, 밑에 적어놓은 원의 좌표 구하는 내용이 더 중요함
       */
      const x = this.radius * Math.cos(angle * i);
      const y = this.radius * Math.sin(angle * i);
      /**
       * 삼각함수로 원의 좌표 구하는 공식 이용 방법.
       * 
       * 그럼 얘내는 Polygon의 꼭지점 좌표를 구하는 애들인데, 이걸 어떻게 구해?
       * 이거는 좀 어려운 개념인데, 구글에 '삼각함수로 원의 좌표 구하기' 라고 검색해서 그림을 보면서 복습할 것.
       * 
       * 이게 뭐냐면, 좌표의 원점을 중심으로 그려진 원이 있다고 치자.
       * 이 원의 둘레에 있는 하나의 점의 좌표를 구하는 원리를 이용한거임.
       * 
       * 이 공식에 따르면, 
       * 원의 반지름은 radius라고 하고,
       * (좌표의 1사분면에 있는 x축)과 (원점에서 해당 점까지의 반지름)이 이루는 각도를 angle이라 하면,
       * 
       * x좌표의 값은 radius * cos(angle)
       * y좌표의 값은 radius * sin(angle) 로 구할 수 있음.
       * 그니까 원의 좌표를 구하는 공식은 (radius*cos(angle), radius*sin(angle))로 정리할 수 있는거지.
       * 
       * 이거는 이해하려고 하지말고 그냥 외우던지 필요할 때 참고해보던지 하는 게 나을 듯ㅋㅋㅋ
       * 
       * 어쨋든 이 공식을 역으로 이용하면, 다각형의 꼭지점의 좌표를 '생성'할 때에도 써먹을 수 있겠지?
       * 왜냐면, 원이라는 것은 결국 무수히 많은 꼭지점으로 이루어진 다각형이라고도 볼 수 있으니까
       * 
       * 삼각형의 꼭지점을 생성하고 싶다면, 3개의 좌표만 구하면 되는거임. 
       * 그래서 원의 각도인 360도(PI2로 표현된 라디안값)를 꼭지점 개수만큼 나눠서, 
       * 그 각도에 해당하는 꼭지점의 좌표를 저런 공식으로 구한거임. 
       */

      // (i === 0) ? ctx.moveTo(x, y): ctx.lineTo(x, y); 가운데에 회전 도형 하나만 그릴 경우
      // i === 0이면 첫 꼭지점의 좌표만 얻은거니까, 당연히 moveTo로 패스그리기를 해당 좌표에서 시작하는 거고,
      // i !== 0이면 두 번째 이후의 꼭지점의 좌표를 얻은것일 테니까, 당연히 lineTo로 해당 좌표로 path를 이어줘야겠지.

      // 꼭지점마다 해당 꼭지점 좌표를 중심으로 하는 원을 여러 개 그릴 경우
      // for loop에서 생성하는 꼭지점 좌표를 써먹어서 for loop안에서 바로 원도 생성해버리는 거
      // ctx.beginPath();
      // ctx.arc(x, y, 30, 0, PI2, false);
      // ctx.fill();

      // 이번에는 꼭지점마다 사각형을 만들어서 회전시켜보자.
      ctx.save()
      ctx.fillStyle = COLORS[i]; // 15개의 사각형들에 순서대로 15개의 컬러를 찍어준 것.
      ctx.translate(x, y) // for문에서 만든 각각의 꼭지점 좌표를 각각의 사각형의 중심으로 하고
      ctx.rotate(((360 / this.sides) * i + 45) * Math.PI / 180);
      // 얘는 변의 갯수에 맞춰 생성된 '사각형들에 각자의 기울기를 줘서' 예쁘게 꽃모양으로 정렬될 수 있도록 함.
      // 그니까 지금 Math.PI / 180는 라디안으로 변환할 때 곱하는 값이니까 상관없고
      // ((360 / this.sides) * i + 45) 얘가 중요한데, 변의 개수대로(예를 들어 지금은 12개) 360도를 나누면 30이지?
      // 그래서 사각형마다 45도, 75도, 105도... 이런식으로 기울기를 주는 거임.
      // 45는 왜 더했을까? ctx.rotate 지우고 확인해보면 사각형들이 '모두 똑같은 다이아몬드 기울기로' 생성됨.
      // 그러면 다이아몬드 기울기롤 똑바른 사각형 기울기로 하려면 어떡할까? 45도 만큼을 기울여주면 되는거야!
      // 이 공식이 이해가 잘 안간다면 공식 안의 숫자들을 하나씩 지워보면서 확인해볼 것.

      ctx.beginPath();
      // 각 꼭지점 좌표마다의 사각형의 꼭지점 좌표 (x2, y2)를 생성하고 걔내를 이어주는 for loop
      for (let j = 0; j < 4; j++) {
        const x2 = 160 * Math.cos(angle2 * j);
        const y2 = 160 * Math.sin(angle2 * j); // 사각형의 꼭지점 4개 좌표를 각각 생성해주고
        (j == 0) ? ctx.moveTo(x2, y2): ctx.lineTo(x2, y2); // 꼭지점을 path로 이어주고
      }
      ctx.fill(); // 색 채우고
      ctx.closePath(); // 마지막 꼭지점 좌표랑 첫번째 좌표랑 이어서 path 닫아주고
      ctx.restore(); // 바깥쪽 for loop를 다시 돌아야 하니까 translate(this.x, this.y)로 원점을 복구시켜줘야 겠지?
    }

    // ctx.fill(); // for loop에서 꼭지점 개수만큼 path를 이어줬으면 지정한 색을 채워주고
    // ctx.closePath(); // 마지막 꼭지점과 첫번째 꼭지점을 이어서 path를 닫아주고
    // 가운데에 회전 도형 하나만 그릴 경우

    ctx.restore(); // animate 메소드에서 맨 처음 저장해놨던 원점 좌표 (0, 0)을 복구해준 거지?
    // 만약에 얘를 복구를 안해준 상태로 또 메소드를 호출하면 
    // ctx.translate(this.x, this.y);로 원점을 재설정해서
    // 실제 원점은 ctx.translate(this.x + this.x, this.y + this.y); 지점에 그려지는거임.
    // 그래서 항상 restore로 원점을 초기화해줘야 함.
  }
}